const fs = require('fs-extra');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const archiver = require('archiver');

class GameGeneratorService {
  constructor() {
    this.gamesDir = path.join(__dirname, '../../generated-games');
    this.templatesDir = path.join(__dirname, '../templates');
    this.ensureDirectories();
  }

  async ensureDirectories() {
    await fs.ensureDir(this.gamesDir);
    await fs.ensureDir(this.templatesDir);
    await fs.ensureDir(path.join(__dirname, '../../builds'));
    await fs.ensureDir(path.join(__dirname, '../../assets'));
  }

  async generateGame(gameSpec) {
    const gameId = uuidv4();
    const gameDir = path.join(this.gamesDir, gameId);
    
    try {
      await fs.ensureDir(gameDir);
      
      // Generate game files based on specification
      await this.generateGameStructure(gameDir, gameSpec);
      await this.generateGameCode(gameDir, gameSpec);
      await this.generateAssets(gameDir, gameSpec);
      await this.generateMaps(gameDir, gameSpec);
      await this.generateStory(gameDir, gameSpec);
      
      // Validate the generated game
      const validation = await this.validateGame(gameDir, gameSpec);
      
      return {
        gameId,
        gameDir,
        validation,
        specification: gameSpec
      };
    } catch (error) {
      console.error('Game generation error:', error);
      throw error;
    }
  }

  async generateGameStructure(gameDir, gameSpec) {
    const structure = {
      'package.json': this.generatePackageJson(gameSpec),
      'index.html': this.generateIndexHtml(gameSpec),
      'README.md': this.generateReadme(gameSpec),
      'game.json': JSON.stringify(gameSpec, null, 2)
    };

    // Create directory structure
    await fs.ensureDir(path.join(gameDir, 'src'));
    await fs.ensureDir(path.join(gameDir, 'assets', 'images'));
    await fs.ensureDir(path.join(gameDir, 'assets', 'sounds'));
    await fs.ensureDir(path.join(gameDir, 'assets', 'music'));
    await fs.ensureDir(path.join(gameDir, 'maps'));
    await fs.ensureDir(path.join(gameDir, 'story'));

    // Write structure files
    for (const [filename, content] of Object.entries(structure)) {
      await fs.writeFile(path.join(gameDir, filename), content);
    }
  }

  async generateGameCode(gameDir, gameSpec) {
    const codeTemplate = this.getCodeTemplate(gameSpec.dimension, gameSpec.genre);
    
    const gameCode = this.generateMainGameCode(gameSpec);
    const playerCode = this.generatePlayerCode(gameSpec);
    const enemyCode = this.generateEnemyCode(gameSpec);
    const uiCode = this.generateUICode(gameSpec);
    const gameManagerCode = this.generateGameManagerCode(gameSpec);

    await fs.writeFile(path.join(gameDir, 'src', 'game.js'), gameCode);
    await fs.writeFile(path.join(gameDir, 'src', 'player.js'), playerCode);
    await fs.writeFile(path.join(gameDir, 'src', 'enemy.js'), enemyCode);
    await fs.writeFile(path.join(gameDir, 'src', 'ui.js'), uiCode);
    await fs.writeFile(path.join(gameDir, 'src', 'gameManager.js'), gameManagerCode);
    
    // Generate CSS
    const cssCode = this.generateCSS(gameSpec);
    await fs.writeFile(path.join(gameDir, 'src', 'style.css'), cssCode);
  }

  generateMainGameCode(gameSpec) {
    return `// ${gameSpec.title} - Main Game Code
// Generated by AI Game Builder

class Game {
  constructor() {
    this.canvas = document.getElementById('gameCanvas');
    this.ctx = this.canvas.getContext('${gameSpec.dimension === '3D' ? 'webgl' : '2d'}');
    this.gameManager = new GameManager(this);
    this.player = new Player(this);
    this.enemies = [];
    this.gameState = 'menu';
    this.level = 1;
    this.score = 0;
    
    this.init();
  }

  init() {
    this.setupCanvas();
    this.bindEvents();
    this.loadAssets().then(() => {
      this.gameLoop();
    });
  }

  setupCanvas() {
    this.canvas.width = ${gameSpec.technical?.resolution?.split('x')[0] || '800'};
    this.canvas.height = ${gameSpec.technical?.resolution?.split('x')[1] || '600'};
  }

  bindEvents() {
    document.addEventListener('keydown', (e) => this.handleKeyDown(e));
    document.addEventListener('keyup', (e) => this.handleKeyUp(e));
    
    ${gameSpec.technical?.platform?.includes('Mobile') ? `
    this.canvas.addEventListener('touchstart', (e) => this.handleTouch(e));
    this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
    ` : ''}
  }

  async loadAssets() {
    // Load game assets
    const assetPromises = [];
    
    ${gameSpec.assets?.sprites?.map(sprite => 
      `assetPromises.push(this.loadImage('assets/images/${sprite}.png'));`
    ).join('\n    ') || ''}
    
    await Promise.all(assetPromises);
  }

  loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  gameLoop() {
    this.update();
    this.render();
    requestAnimationFrame(() => this.gameLoop());
  }

  update() {
    if (this.gameState === 'playing') {
      this.player.update();
      this.enemies.forEach(enemy => enemy.update());
      this.gameManager.update();
    }
  }

  render() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    switch (this.gameState) {
      case 'menu':
        this.renderMenu();
        break;
      case 'playing':
        this.renderGame();
        break;
      case 'gameOver':
        this.renderGameOver();
        break;
    }
  }

  renderMenu() {
    this.ctx.fillStyle = '#000';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    this.ctx.fillStyle = '#fff';
    this.ctx.font = '48px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('${gameSpec.title}', this.canvas.width / 2, this.canvas.height / 2 - 50);
    
    this.ctx.font = '24px Arial';
    this.ctx.fillText('Press SPACE to start', this.canvas.width / 2, this.canvas.height / 2 + 50);
  }

  renderGame() {
    // Render game world
    this.player.render(this.ctx);
    this.enemies.forEach(enemy => enemy.render(this.ctx));
    
    // Render UI
    this.renderUI();
  }

  renderUI() {
    this.ctx.fillStyle = '#fff';
    this.ctx.font = '20px Arial';
    this.ctx.textAlign = 'left';
    this.ctx.fillText(\`Score: \${this.score}\`, 10, 30);
    this.ctx.fillText(\`Level: \${this.level}\`, 10, 60);
  }

  renderGameOver() {
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    this.ctx.fillStyle = '#fff';
    this.ctx.font = '48px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('Game Over', this.canvas.width / 2, this.canvas.height / 2 - 50);
    
    this.ctx.font = '24px Arial';
    this.ctx.fillText(\`Final Score: \${this.score}\`, this.canvas.width / 2, this.canvas.height / 2);
    this.ctx.fillText('Press R to restart', this.canvas.width / 2, this.canvas.height / 2 + 50);
  }

  handleKeyDown(e) {
    switch (e.code) {
      case 'Space':
        if (this.gameState === 'menu') {
          this.startGame();
        }
        break;
      case 'KeyR':
        if (this.gameState === 'gameOver') {
          this.resetGame();
        }
        break;
    }
    
    if (this.gameState === 'playing') {
      this.player.handleKeyDown(e);
    }
  }

  handleKeyUp(e) {
    if (this.gameState === 'playing') {
      this.player.handleKeyUp(e);
    }
  }

  startGame() {
    this.gameState = 'playing';
    this.resetGame();
  }

  resetGame() {
    this.score = 0;
    this.level = 1;
    this.enemies = [];
    this.player.reset();
    this.gameState = 'playing';
  }

  gameOver() {
    this.gameState = 'gameOver';
  }
}

// Initialize game when page loads
window.addEventListener('load', () => {
  new Game();
});`;
  }

  generatePlayerCode(gameSpec) {
    return `// Player class for ${gameSpec.title}

class Player {
  constructor(game) {
    this.game = game;
    this.x = 100;
    this.y = 100;
    this.width = 32;
    this.height = 32;
    this.velocityX = 0;
    this.velocityY = 0;
    this.speed = 5;
    this.health = 100;
    this.maxHealth = 100;
    
    this.keys = {
      left: false,
      right: false,
      up: false,
      down: false,
      jump: false
    };
  }

  update() {
    this.handleMovement();
    this.updatePosition();
    this.checkBounds();
  }

  handleMovement() {
    this.velocityX = 0;
    
    if (this.keys.left) {
      this.velocityX = -this.speed;
    }
    if (this.keys.right) {
      this.velocityX = this.speed;
    }
    
    ${gameSpec.genre === 'Platformer' ? `
    if (this.keys.jump && this.onGround) {
      this.velocityY = -15;
      this.onGround = false;
    }
    
    // Apply gravity
    this.velocityY += 0.8;
    ` : `
    this.velocityY = 0;
    if (this.keys.up) {
      this.velocityY = -this.speed;
    }
    if (this.keys.down) {
      this.velocityY = this.speed;
    }
    `}
  }

  updatePosition() {
    this.x += this.velocityX;
    this.y += this.velocityY;
  }

  checkBounds() {
    if (this.x < 0) this.x = 0;
    if (this.x + this.width > this.game.canvas.width) {
      this.x = this.game.canvas.width - this.width;
    }
    if (this.y < 0) this.y = 0;
    if (this.y + this.height > this.game.canvas.height) {
      this.y = this.game.canvas.height - this.height;
      ${gameSpec.genre === 'Platformer' ? 'this.onGround = true; this.velocityY = 0;' : ''}
    }
  }

  render(ctx) {
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(this.x, this.y, this.width, this.height);
    
    // Health bar
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(this.x, this.y - 10, this.width, 5);
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(this.x, this.y - 10, (this.width * this.health) / this.maxHealth, 5);
  }

  handleKeyDown(e) {
    switch (e.code) {
      case 'ArrowLeft':
      case 'KeyA':
        this.keys.left = true;
        break;
      case 'ArrowRight':
      case 'KeyD':
        this.keys.right = true;
        break;
      case 'ArrowUp':
      case 'KeyW':
        this.keys.up = true;
        break;
      case 'ArrowDown':
      case 'KeyS':
        this.keys.down = true;
        break;
      case 'Space':
        this.keys.jump = true;
        break;
    }
  }

  handleKeyUp(e) {
    switch (e.code) {
      case 'ArrowLeft':
      case 'KeyA':
        this.keys.left = false;
        break;
      case 'ArrowRight':
      case 'KeyD':
        this.keys.right = false;
        break;
      case 'ArrowUp':
      case 'KeyW':
        this.keys.up = false;
        break;
      case 'ArrowDown':
      case 'KeyS':
        this.keys.down = false;
        break;
      case 'Space':
        this.keys.jump = false;
        break;
    }
  }

  takeDamage(amount) {
    this.health -= amount;
    if (this.health <= 0) {
      this.game.gameOver();
    }
  }

  reset() {
    this.x = 100;
    this.y = 100;
    this.velocityX = 0;
    this.velocityY = 0;
    this.health = this.maxHealth;
  }
}`;
  }

  generateEnemyCode(gameSpec) {
    return `// Enemy classes for ${gameSpec.title}

class Enemy {
  constructor(game, x, y, type = 'basic') {
    this.game = game;
    this.x = x;
    this.y = y;
    this.type = type;
    this.width = 24;
    this.height = 24;
    this.health = 50;
    this.speed = 2;
    this.direction = 1;
    this.attackCooldown = 0;
  }

  update() {
    this.move();
    this.checkCollisions();
    if (this.attackCooldown > 0) {
      this.attackCooldown--;
    }
  }

  move() {
    // Basic AI movement
    this.x += this.speed * this.direction;
    
    // Bounce off screen edges
    if (this.x <= 0 || this.x + this.width >= this.game.canvas.width) {
      this.direction *= -1;
    }
  }

  checkCollisions() {
    const player = this.game.player;
    if (this.x < player.x + player.width &&
        this.x + this.width > player.x &&
        this.y < player.y + player.height &&
        this.y + this.height > player.y) {
      this.attackPlayer();
    }
  }

  attackPlayer() {
    if (this.attackCooldown === 0) {
      this.game.player.takeDamage(10);
      this.attackCooldown = 60; // 1 second at 60fps
    }
  }

  render(ctx) {
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }

  takeDamage(amount) {
    this.health -= amount;
    if (this.health <= 0) {
      this.destroy();
    }
  }

  destroy() {
    const index = this.game.enemies.indexOf(this);
    if (index > -1) {
      this.game.enemies.splice(index, 1);
      this.game.score += 100;
    }
  }
}

class EnemySpawner {
  constructor(game) {
    this.game = game;
    this.spawnTimer = 0;
    this.spawnRate = 120; // Spawn every 2 seconds at 60fps
  }

  update() {
    this.spawnTimer++;
    if (this.spawnTimer >= this.spawnRate) {
      this.spawnEnemy();
      this.spawnTimer = 0;
    }
  }

  spawnEnemy() {
    const x = Math.random() * (this.game.canvas.width - 24);
    const y = Math.random() * (this.game.canvas.height - 24);
    const enemy = new Enemy(this.game, x, y);
    this.game.enemies.push(enemy);
  }
}`;
  }

  generateUICode(gameSpec) {
    return `// UI system for ${gameSpec.title}

class UI {
  constructor(game) {
    this.game = game;
    this.elements = [];
    this.setupUI();
  }

  setupUI() {
    // Create UI elements based on game specification
    this.createHUD();
    this.createMenus();
  }

  createHUD() {
    this.elements.push({
      type: 'healthBar',
      x: 10,
      y: 10,
      width: 200,
      height: 20
    });

    this.elements.push({
      type: 'scoreText',
      x: 10,
      y: 40,
      text: 'Score: 0'
    });

    this.elements.push({
      type: 'levelText',
      x: 10,
      y: 70,
      text: 'Level: 1'
    });
  }

  createMenus() {
    // Main menu elements
    this.menuElements = [
      {
        type: 'button',
        text: 'Start Game',
        x: this.game.canvas.width / 2 - 100,
        y: this.game.canvas.height / 2,
        width: 200,
        height: 50,
        action: () => this.game.startGame()
      },
      {
        type: 'button',
        text: 'Settings',
        x: this.game.canvas.width / 2 - 100,
        y: this.game.canvas.height / 2 + 60,
        width: 200,
        height: 50,
        action: () => this.showSettings()
      }
    ];
  }

  update() {
    // Update UI elements
    this.elements.forEach(element => {
      if (element.type === 'scoreText') {
        element.text = \`Score: \${this.game.score}\`;
      }
      if (element.type === 'levelText') {
        element.text = \`Level: \${this.game.level}\`;
      }
    });
  }

  render(ctx) {
    if (this.game.gameState === 'playing') {
      this.renderHUD(ctx);
    } else if (this.game.gameState === 'menu') {
      this.renderMenu(ctx);
    }
  }

  renderHUD(ctx) {
    this.elements.forEach(element => {
      switch (element.type) {
        case 'healthBar':
          this.renderHealthBar(ctx, element);
          break;
        case 'scoreText':
        case 'levelText':
          this.renderText(ctx, element);
          break;
      }
    });
  }

  renderHealthBar(ctx, element) {
    const healthPercent = this.game.player.health / this.game.player.maxHealth;
    
    // Background
    ctx.fillStyle = '#333';
    ctx.fillRect(element.x, element.y, element.width, element.height);
    
    // Health bar
    ctx.fillStyle = healthPercent > 0.3 ? '#00ff00' : '#ff0000';
    ctx.fillRect(element.x, element.y, element.width * healthPercent, element.height);
    
    // Border
    ctx.strokeStyle = '#fff';
    ctx.strokeRect(element.x, element.y, element.width, element.height);
  }

  renderText(ctx, element) {
    ctx.fillStyle = '#fff';
    ctx.font = '18px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(element.text, element.x, element.y);
  }

  renderMenu(ctx) {
    this.menuElements.forEach(element => {
      if (element.type === 'button') {
        this.renderButton(ctx, element);
      }
    });
  }

  renderButton(ctx, button) {
    // Button background
    ctx.fillStyle = '#444';
    ctx.fillRect(button.x, button.y, button.width, button.height);
    
    // Button border
    ctx.strokeStyle = '#fff';
    ctx.strokeRect(button.x, button.y, button.width, button.height);
    
    // Button text
    ctx.fillStyle = '#fff';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(button.text, button.x + button.width / 2, button.y + button.height / 2 + 7);
  }

  handleClick(x, y) {
    if (this.game.gameState === 'menu') {
      this.menuElements.forEach(element => {
        if (element.type === 'button' &&
            x >= element.x && x <= element.x + element.width &&
            y >= element.y && y <= element.y + element.height) {
          element.action();
        }
      });
    }
  }

  showSettings() {
    // Settings implementation would go here
    console.log('Settings menu would open here');
  }
}`;
  }

  generateGameManagerCode(gameSpec) {
    return `// Game Manager for ${gameSpec.title}

class GameManager {
  constructor(game) {
    this.game = game;
    this.ui = new UI(game);
    this.enemySpawner = new EnemySpawner(game);
    this.levelProgress = 0;
    this.levelGoal = 1000; // Score needed to advance level
  }

  update() {
    this.ui.update();
    
    if (this.game.gameState === 'playing') {
      this.enemySpawner.update();
      this.checkLevelProgression();
      this.updateGameLogic();
    }
  }

  updateGameLogic() {
    // Game-specific logic based on genre
    ${this.generateGenreSpecificLogic(gameSpec)}
  }

  checkLevelProgression() {
    if (this.game.score >= this.levelGoal * this.game.level) {
      this.advanceLevel();
    }
  }

  advanceLevel() {
    this.game.level++;
    this.enemySpawner.spawnRate = Math.max(30, this.enemySpawner.spawnRate - 10);
    
    // Show level up message
    this.showLevelUpMessage();
  }

  showLevelUpMessage() {
    // This would show a temporary message overlay
    console.log(\`Level \${this.game.level} reached!\`);
  }

  render(ctx) {
    this.ui.render(ctx);
  }

  handleInput(input) {
    // Handle game manager specific inputs
    if (input.type === 'click') {
      this.ui.handleClick(input.x, input.y);
    }
  }

  saveGameState() {
    const gameState = {
      score: this.game.score,
      level: this.game.level,
      playerPosition: { x: this.game.player.x, y: this.game.player.y },
      timestamp: Date.now()
    };
    
    localStorage.setItem('${gameSpec.title.replace(/\s+/g, '_')}_save', JSON.stringify(gameState));
  }

  loadGameState() {
    const saved = localStorage.getItem('${gameSpec.title.replace(/\s+/g, '_')}_save');
    if (saved) {
      const gameState = JSON.parse(saved);
      this.game.score = gameState.score;
      this.game.level = gameState.level;
      this.game.player.x = gameState.playerPosition.x;
      this.game.player.y = gameState.playerPosition.y;
      return true;
    }
    return false;
  }
}`;
  }

  generateGenreSpecificLogic(gameSpec) {
    switch (gameSpec.genre) {
      case 'RPG':
        return `
    // RPG-specific logic
    this.checkQuests();
    this.updateExperience();
    this.manageInventory();`;
      case 'Platformer':
        return `
    // Platformer-specific logic
    this.checkCollectibles();
    this.updatePhysics();
    this.checkCheckpoints();`;
      case 'Puzzle':
        return `
    // Puzzle-specific logic
    this.checkPuzzleCompletion();
    this.validateMoves();
    this.updateHints();`;
      default:
        return `
    // Generic game logic
    this.updateScore();
    this.checkObjectives();`;
    }
  }

  generateCSS(gameSpec) {
    return `/* Styles for ${gameSpec.title} */

body {
  margin: 0;
  padding: 0;
  background-color: #000;
  font-family: Arial, sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  color: white;
}

#gameContainer {
  text-align: center;
  border: 2px solid #333;
  border-radius: 10px;
  padding: 20px;
  background-color: #111;
}

#gameCanvas {
  border: 1px solid #555;
  background-color: #222;
  display: block;
  margin: 0 auto;
}

h1 {
  color: #fff;
  margin-bottom: 10px;
}

.game-info {
  margin-top: 10px;
  font-size: 14px;
  color: #ccc;
}

.controls {
  margin-top: 15px;
  padding: 10px;
  background-color: #333;
  border-radius: 5px;
}

.controls h3 {
  margin: 0 0 10px 0;
  color: #fff;
}

.controls p {
  margin: 5px 0;
  font-size: 12px;
}

.loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.8);
  padding: 20px;
  border-radius: 5px;
  color: white;
}

@media (max-width: 768px) {
  #gameContainer {
    padding: 10px;
    margin: 10px;
  }
  
  #gameCanvas {
    max-width: 100%;
    height: auto;
  }
}`;
  }

  generatePackageJson(gameSpec) {
    return JSON.stringify({
      name: gameSpec.title.toLowerCase().replace(/\s+/g, '-'),
      version: "1.0.0",
      description: gameSpec.story?.premise || `A ${gameSpec.genre} game`,
      main: "index.html",
      scripts: {
        start: "npx http-server . -p 8080",
        build: "echo 'Build complete'",
        deploy: "echo 'Deploy to your preferred platform'"
      },
      keywords: [gameSpec.genre.toLowerCase(), gameSpec.dimension.toLowerCase(), "game"],
      author: "AI Game Builder",
      license: "MIT"
    }, null, 2);
  }

  generateIndexHtml(gameSpec) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${gameSpec.title}</title>
    <link rel="stylesheet" href="src/style.css">
</head>
<body>
    <div id="gameContainer">
        <h1>${gameSpec.title}</h1>
        <canvas id="gameCanvas"></canvas>
        <div class="game-info">
            <p>Genre: ${gameSpec.genre} | Style: ${gameSpec.artStyle} | Target: ${gameSpec.targetAudience}</p>
        </div>
        <div class="controls">
            <h3>Controls:</h3>
            <p>Arrow Keys / WASD: Move</p>
            <p>Space: ${gameSpec.genre === 'Platformer' ? 'Jump' : 'Action'}</p>
            <p>R: Restart (when game over)</p>
        </div>
    </div>

    <script src="src/gameManager.js"></script>
    <script src="src/ui.js"></script>
    <script src="src/player.js"></script>
    <script src="src/enemy.js"></script>
    <script src="src/game.js"></script>
</body>
</html>`;
  }

  generateReadme(gameSpec) {
    return `# ${gameSpec.title}

${gameSpec.story?.premise || `A ${gameSpec.genre} game created with AI Game Builder.`}

## Game Details

- **Genre**: ${gameSpec.genre}
- **Dimension**: ${gameSpec.dimension}
- **Art Style**: ${gameSpec.artStyle}
- **Target Audience**: ${gameSpec.targetAudience}

## Story

${gameSpec.story?.premise || 'No story provided.'}

### Main Character
${gameSpec.story?.mainCharacter || 'Player character'}

### Setting
${gameSpec.story?.setting || 'Game world'}

## Gameplay

### Core Mechanics
${gameSpec.coreGameplay?.mechanics?.map(m => `- ${m}`).join('\n') || '- Basic gameplay mechanics'}

### Objectives
${gameSpec.coreGameplay?.objectives || 'Complete the game'}

### Progression
${gameSpec.coreGameplay?.progression || 'Progress through levels'}

## Controls

- Arrow Keys / WASD: Move
- Space: ${gameSpec.genre === 'Platformer' ? 'Jump' : 'Action'}
- R: Restart (when game over)

## How to Play

1. Open \`index.html\` in your web browser
2. Or run \`npm start\` to serve the game locally
3. Follow the on-screen instructions

## Technical Details

- **Platforms**: ${gameSpec.technical?.platform?.join(', ') || 'Web'}
- **Engine**: ${gameSpec.technical?.engine || 'HTML5 Canvas'}
- **Resolution**: ${gameSpec.technical?.resolution || '800x600'}

## Generated by AI Game Builder

This game was created using the AI Game Builder system. All code, assets, and game logic were generated based on conversational input.

## License

MIT License - Feel free to modify and distribute this game.
`;
  }

  async generateAssets(gameDir, gameSpec) {
    // Generate placeholder assets
    const assetsDir = path.join(gameDir, 'assets');
    
    // Generate simple colored rectangles as placeholder sprites
    if (gameSpec.assets?.sprites) {
      for (const sprite of gameSpec.assets.sprites) {
        await this.generatePlaceholderImage(
          path.join(assetsDir, 'images', `${sprite}.png`),
          32, 32, this.getRandomColor()
        );
      }
    }

    // Generate asset manifest
    const assetManifest = {
      images: gameSpec.assets?.sprites?.map(sprite => ({
        name: sprite,
        file: `images/${sprite}.png`,
        width: 32,
        height: 32
      })) || [],
      sounds: gameSpec.assets?.sounds?.map(sound => ({
        name: sound,
        file: `sounds/${sound}.mp3`
      })) || [],
      music: gameSpec.assets?.music?.map(music => ({
        name: music,
        file: `music/${music}.mp3`
      })) || []
    };

    await fs.writeFile(
      path.join(assetsDir, 'manifest.json'),
      JSON.stringify(assetManifest, null, 2)
    );
  }

  async generatePlaceholderImage(filePath, width, height, color) {
    // Generate a simple SVG placeholder
    const svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
      <rect width="${width}" height="${height}" fill="${color}"/>
    </svg>`;
    
    // For now, just save the SVG. In a real implementation, you'd convert to PNG
    await fs.writeFile(filePath.replace('.png', '.svg'), svg);
  }

  getRandomColor() {
    const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  async generateMaps(gameDir, gameSpec) {
    const mapsDir = path.join(gameDir, 'maps');
    
    if (gameSpec.levels) {
      for (let i = 0; i < gameSpec.levels.length; i++) {
        const level = gameSpec.levels[i];
        const mapData = {
          name: level.name,
          description: level.description,
          width: 800,
          height: 600,
          tiles: this.generateTileMap(800, 600),
          entities: this.generateLevelEntities(level),
          spawn: { x: 100, y: 100 },
          objectives: level.objectives || []
        };
        
        await fs.writeFile(
          path.join(mapsDir, `level${i + 1}.json`),
          JSON.stringify(mapData, null, 2)
        );
      }
    }
  }

  generateTileMap(width, height) {
    const tileSize = 32;
    const cols = Math.ceil(width / tileSize);
    const rows = Math.ceil(height / tileSize);
    const tiles = [];
    
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        // Simple ground and platform generation
        let tileType = 0; // 0 = empty, 1 = ground, 2 = platform
        
        if (y === rows - 1) {
          tileType = 1; // Ground
        } else if (Math.random() < 0.1) {
          tileType = 2; // Platform
        }
        
        tiles.push(tileType);
      }
    }
    
    return tiles;
  }

  generateLevelEntities(level) {
    const entities = [];
    
    // Add enemies
    if (level.enemies) {
      for (const enemyType of level.enemies) {
        entities.push({
          type: 'enemy',
          subtype: enemyType,
          x: Math.random() * 700 + 50,
          y: Math.random() * 500 + 50
        });
      }
    }
    
    // Add collectibles
    if (level.collectibles) {
      for (const collectibleType of level.collectibles) {
        entities.push({
          type: 'collectible',
          subtype: collectibleType,
          x: Math.random() * 700 + 50,
          y: Math.random() * 500 + 50
        });
      }
    }
    
    return entities;
  }

  async generateStory(gameDir, gameSpec) {
    const storyDir = path.join(gameDir, 'story');
    
    if (gameSpec.story) {
      const storyData = {
        premise: gameSpec.story.premise,
        mainCharacter: gameSpec.story.mainCharacter,
        setting: gameSpec.story.setting,
        keyEvents: gameSpec.story.keyEvents || [],
        endings: gameSpec.story.endings || [],
        dialogue: this.generateDialogue(gameSpec.story),
        cutscenes: this.generateCutscenes(gameSpec.story)
      };
      
      await fs.writeFile(
        path.join(storyDir, 'story.json'),
        JSON.stringify(storyData, null, 2)
      );
      
      // Generate individual dialogue files
      if (storyData.dialogue) {
        for (const [character, lines] of Object.entries(storyData.dialogue)) {
          await fs.writeFile(
            path.join(storyDir, `${character}_dialogue.json`),
            JSON.stringify(lines, null, 2)
          );
        }
      }
    }
  }

  generateDialogue(story) {
    return {
      narrator: [
        "Welcome to the adventure!",
        "Your journey begins now...",
        "What will you choose?"
      ],
      player: [
        "I'm ready for this challenge.",
        "Let's see what happens next.",
        "This looks interesting."
      ],
      npc: [
        "Greetings, traveler!",
        "I have a quest for you.",
        "Be careful on your journey."
      ]
    };
  }

  generateCutscenes(story) {
    return [
      {
        id: "intro",
        title: "Introduction",
        scenes: [
          {
            text: story.premise || "The adventure begins...",
            duration: 3000,
            background: "intro_bg"
          }
        ]
      },
      {
        id: "ending",
        title: "Conclusion",
        scenes: [
          {
            text: "Congratulations! You've completed the game!",
            duration: 3000,
            background: "ending_bg"
          }
        ]
      }
    ];
  }

  async validateGame(gameDir, gameSpec) {
    const validation = {
      valid: true,
      errors: [],
      warnings: [],
      files: []
    };

    try {
      // Check required files exist
      const requiredFiles = [
        'index.html',
        'src/game.js',
        'src/player.js',
        'package.json',
        'game.json'
      ];

      for (const file of requiredFiles) {
        const filePath = path.join(gameDir, file);
        if (await fs.pathExists(filePath)) {
          validation.files.push({ file, status: 'exists' });
        } else {
          validation.errors.push(`Missing required file: ${file}`);
          validation.valid = false;
        }
      }

      // Validate game specification
      if (!gameSpec.title) {
        validation.errors.push('Game title is required');
        validation.valid = false;
      }

      if (!gameSpec.genre) {
        validation.warnings.push('Game genre not specified');
      }

      // Check for assets
      const assetsDir = path.join(gameDir, 'assets');
      if (await fs.pathExists(assetsDir)) {
        validation.files.push({ file: 'assets/', status: 'exists' });
      } else {
        validation.warnings.push('No assets directory found');
      }

      validation.summary = `Validation ${validation.valid ? 'passed' : 'failed'} with ${validation.errors.length} errors and ${validation.warnings.length} warnings`;

    } catch (error) {
      validation.valid = false;
      validation.errors.push(`Validation error: ${error.message}`);
    }

    return validation;
  }

  async createGameBuild(gameId, platforms = ['web']) {
    const gameDir = path.join(this.gamesDir, gameId);
    const buildsDir = path.join(__dirname, '../../builds');
    
    const builds = {};

    for (const platform of platforms) {
      switch (platform.toLowerCase()) {
        case 'web':
          builds.web = await this.createWebBuild(gameDir, buildsDir, gameId);
          break;
        case 'pc':
          builds.pc = await this.createPCBuild(gameDir, buildsDir, gameId);
          break;
        case 'mobile':
          builds.mobile = await this.createMobileBuild(gameDir, buildsDir, gameId);
          break;
      }
    }

    return builds;
  }

  async createWebBuild(gameDir, buildsDir, gameId) {
    const webBuildDir = path.join(buildsDir, `${gameId}-web`);
    await fs.ensureDir(webBuildDir);
    
    // Copy all game files
    await fs.copy(gameDir, webBuildDir);
    
    // Create a zip file for download
    const zipPath = path.join(buildsDir, `${gameId}-web.zip`);
    await this.createZipArchive(webBuildDir, zipPath);
    
    return {
      platform: 'web',
      buildPath: webBuildDir,
      downloadPath: zipPath,
      playUrl: `/builds/${gameId}-web/index.html`
    };
  }

  async createPCBuild(gameDir, buildsDir, gameId) {
    // For now, create a simple executable wrapper
    const pcBuildDir = path.join(buildsDir, `${gameId}-pc`);
    await fs.ensureDir(pcBuildDir);
    
    // Copy game files
    await fs.copy(gameDir, path.join(pcBuildDir, 'game'));
    
    // Create a simple batch file to run the game
    const batchContent = `@echo off
echo Starting ${gameId}...
cd game
npx http-server . -p 8080 -o
pause`;
    
    await fs.writeFile(path.join(pcBuildDir, 'run_game.bat'), batchContent);
    
    const zipPath = path.join(buildsDir, `${gameId}-pc.zip`);
    await this.createZipArchive(pcBuildDir, zipPath);
    
    return {
      platform: 'pc',
      buildPath: pcBuildDir,
      downloadPath: zipPath
    };
  }

  async createMobileBuild(gameDir, buildsDir, gameId) {
    // Create a mobile-optimized version
    const mobileBuildDir = path.join(buildsDir, `${gameId}-mobile`);
    await fs.ensureDir(mobileBuildDir);
    
    // Copy and modify game files for mobile
    await fs.copy(gameDir, mobileBuildDir);
    
    // Add mobile-specific meta tags and touch controls
    const indexPath = path.join(mobileBuildDir, 'index.html');
    let indexContent = await fs.readFile(indexPath, 'utf8');
    
    const mobileMetaTags = `
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">`;
    
    indexContent = indexContent.replace('<meta name="viewport"', mobileMetaTags + '\n    <meta name="viewport"');
    await fs.writeFile(indexPath, indexContent);
    
    const zipPath = path.join(buildsDir, `${gameId}-mobile.zip`);
    await this.createZipArchive(mobileBuildDir, zipPath);
    
    return {
      platform: 'mobile',
      buildPath: mobileBuildDir,
      downloadPath: zipPath
    };
  }

  async createZipArchive(sourceDir, outputPath) {
    return new Promise((resolve, reject) => {
      const output = fs.createWriteStream(outputPath);
      const archive = archiver('zip', { zlib: { level: 9 } });
      
      output.on('close', () => resolve(outputPath));
      archive.on('error', reject);
      
      archive.pipe(output);
      archive.directory(sourceDir, false);
      archive.finalize();
    });
  }

  getCodeTemplate(dimension, genre) {
    // This would return appropriate code templates based on dimension and genre
    return {
      dimension,
      genre,
      template: 'basic-canvas-game'
    };
  }
}

module.exports = new GameGeneratorService();